# 二分查找

<!--
create time: 2018-05-16 10:51:46
Author: <黄东鸿>
-->

## 算法思想

**正常实现** 

```java
public int binarySearch(int[] nums, int key) {
    int l = 0, h = nums.length - 1;
    while (l <= h) {
        int m = l + (h - l) / 2;
        if (nums[m] == key)
            return m;
        else if (nums[m] > key)
            h = m - 1;
        else
            l = m + 1;
    }
    return -1;
}
```

**时间复杂度** 

O(logN)

**计算 mid** 

有两种计算 mid 的方式：

- mid = (l + h) / 2
- mid = l + (h - l) / 2

l + h 可能出现加法溢出，最好使用第二种方式。

**返回值** 

循环退出时如果仍然没有查找到 key，那么表示查找失败。可以有两种返回值：

- -1：以一个错误码指示没有查找到 key
- l：将 key 插入到 nums 中的正确位置

**变种** 

二分查找可以有很多变种，变种实现要多注意边界值的判断。例如在一个有重复元素的数组中查找 key 的最左位置的实现如下：

```java
public int binarySearch(int[] nums, int key) {
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[m] >= key)
            h = m;
        else
            l = m + 1;
    }
    return l;
}
```

该实现和正常实现有以下不同：

- 循环条件为 l < h
- h 的赋值表达式为 h = m
- 最后返回 l 而不是 -1

在 nums[m] >= key 的情况下，可以推导出最左 key 位于 [l, m] 区间中，这是一个闭区间。h 的赋值表达式为 h = m，因为 m 位置也可能是解。

在 h 的赋值表达式为 h = mid 的情况下，如果循环条件为 l <= h，那么会出现循环无法退出的情况，因此循环条件只能是 l < h。

当循环体退出时，不表示没有查找到 key，因此最后返回的结果不应该为 -1。为了验证有没有查找到，需要在调用端判断一下返回位置上的值和 key 是否相等。

## 题目

HDU 1969
